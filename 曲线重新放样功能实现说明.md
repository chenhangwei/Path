# 曲线重新放样功能实现说明

## ? 功能已实现

**需求**: 允许对已经放样的曲线再次进行放样（重新放样）

**实现**: 添加智能检测和用户确认机制，支持重新放样

---

## ?? 实现方案

### 问题分析

**修改前的逻辑**:
```csharp
foreach (var curve in Curves)
{
 if (!curve.IsLofted)  // ? 跳过已放样的曲线
    {
        // 执行放样...
        curve.IsLofted = true;
    }
}
```

**问题**:
```
场景：用户修改了放样点数
1. 导入曲线 → 设置点数 10
2. 放样全部 → 生成 10 个点
3. 修改点数为 20
4. 再次放样 → ? 跳过已放样曲线
5. 结果：还是 10 个点
```

---

## ?? 解决方案

### 方案对比

**方案1**: 总是重新放样（不推荐）
```
优点: 简单直接
缺点: 
- 可能意外覆盖用户数据
- 没有确认机制
- 不安全
```

**方案2**: 智能检测 + 用户确认 ? **已采用**
```
优点:
- 安全：询问用户意见
- 灵活：可选择性重新放样
- 智能：只在需要时提示
- 用户友好
```

---

## ?? 实现细节

### 1. 单条曲线放样

**方法**: `LoftSelectedCurve()`

**新增逻辑**:
```csharp
[RelayCommand]
private void LoftSelectedCurve()
{
    if (SelectedCurve == null) return;
    
    try
    {
    IsBusy = true;
        
        // ? 新增：如果已放样，提示用户
        if (SelectedCurve.IsLofted)
  {
         var result = _dialogService.ShowConfirmation(
                $"曲线 {SelectedCurve.Name} 已经放样过。\n\n" +
  $"是否重新放样？\n\n" +
 $"当前放样点数: {SelectedCurve.LoftPointCount}");
        
    if (!result)
    {
  StatusMessage = "已取消重新放样";
         return;
    }
        }
        
        // 执行放样
        SelectedCurve.LoftedPoints = _loftService.LoftCurve(
            SelectedCurve.OriginalPoints,
    SelectedCurve.LoftPointCount);
    
        SelectedCurve.IsLofted = true;
        StatusMessage = $"曲线 {SelectedCurve.Name} 已放样，生成 {SelectedCurve.LoftPointCount} 个点";
    }
    finally
    {
        IsBusy = false;
 }
}
```

**工作流程**:
```
1. 用户点击"放样选中"或执行放样命令
2. ? 检查曲线是否已放样
3. ? 如果已放样，弹出确认对话框
4. 用户选择：
   - 是 → 重新放样
   - 否 → 取消操作
```

---

### 2. 批量放样

**方法**: `LoftAllCurves()`

**新增逻辑**:
```csharp
[RelayCommand]
private void LoftAllCurves()
{
    if (Curves.Count == 0)
    {
        _dialogService.ShowMessage("没有可放样的曲线");
        return;
    }
    
    try
    {
        IsBusy = true;
        
        // ? 新增：检查是否有已放样的曲线
        var alreadyLoftedCurves = Curves.Where(c => c.IsLofted).ToList();
        bool reloftAll = false;
        
        if (alreadyLoftedCurves.Count > 0)
        {
         var message = $"检测到 {alreadyLoftedCurves.Count} 条曲线已经放样过：\n\n";
            message += string.Join("\n", alreadyLoftedCurves.Take(5).Select(c => $"  ? {c.Name}"));
         if (alreadyLoftedCurves.Count > 5)
        {
      message += $"\n  ... 还有 {alreadyLoftedCurves.Count - 5} 条";
        }
     message += "\n\n是否重新放样这些曲线？\n\n";
  message += "选择：\n";
          message += "? 是 - 重新放样所有曲线（包括已放样的）\n";
            message += "? 否 - 只放样未放样的曲线";
   
            var result = _dialogService.ShowConfirmation(message);
    reloftAll = result;
    }
        
        int loftedCount = 0;
 
     foreach (var curve in Curves)
        {
  // ? 根据用户选择决定是否跳过已放样的曲线
         if (!curve.IsLofted || reloftAll)
            {
     curve.LoftedPoints = _loftService.LoftCurve(
      curve.OriginalPoints,
  curve.LoftPointCount);
                curve.IsLofted = true;
      loftedCount++;
            }
 }
        
        var statusMsg = reloftAll && alreadyLoftedCurves.Count > 0
            ? $"已重新放样 {loftedCount} 条曲线"
         : $"已放样 {loftedCount} 条曲线";
        
    StatusMessage = statusMsg;
        _dialogService.ShowMessage($"成功{(reloftAll && alreadyLoftedCurves.Count > 0 ? "重新" : "")}放样 {loftedCount} 条曲线");
    }
    catch (Exception ex)
    {
        _dialogService.ShowError($"批量放样失败: {ex.Message}");
        StatusMessage = "批量放样失败";
    }
    finally
 {
        IsBusy = false;
    }
}
```

**工作流程**:
```
1. 用户点击"放样全部"
2. ? 检测已放样的曲线数量
3. 如果有已放样的曲线：
   ? 显示详细的确认对话框
   ? 列出已放样曲线的名称（最多5条）
   ? 提供两个选择
4. 用户选择：
   - 是 → 重新放样所有曲线
   - 否 → 只放样未放样的曲线
5. 执行放样并显示结果
```

---

## ?? 确认对话框设计

### 单条曲线确认

```
┌──────────────────────────────────┐
│ 确认  │
├──────────────────────────────────┤
│ 曲线 usv_01 已经放样过。│
│              │
│ 是否重新放样？     │
│        │
│ 当前放样点数: 10  │
├──────────────────────────────────┤
│           [是]      [否]          │
└──────────────────────────────────┘
```

### 批量放样确认

**场景1: 少量已放样曲线（≤5条）**

```
┌──────────────────────────────────┐
│ 确认         │
├──────────────────────────────────┤
│ 检测到 3 条曲线已经放样过：       │
││
│   ? usv_01           │
│   ? usv_02 │
│   ? usv_03      │
│    │
│ 是否重新放样这些曲线？│
│ │
│ 选择：   │
│ ? 是 - 重新放样所有曲线           │
│       （包括已放样的）  │
│ ? 否 - 只放样未放样的曲线  │
├──────────────────────────────────┤
│           [是]      [否]  │
└──────────────────────────────────┘
```

**场景2: 大量已放样曲线（>5条）**

```
┌──────────────────────────────────┐
│ 确认             │
├──────────────────────────────────┤
│ 检测到 8 条曲线已经放样过：       │
│      │
│   ? usv_01              │
│   ? usv_02    │
│   ? usv_03   │
│   ? usv_04     │
│   ? usv_05   │
│   ... 还有 3 条     │
│           │
│ 是否重新放样这些曲线？        │
│      │
│ 选择：        │
│ ? 是 - 重新放样所有曲线│
│       （包括已放样的）        │
│ ? 否 - 只放样未放样的曲线         │
├──────────────────────────────────┤
│           [是]      [否] │
└──────────────────────────────────┘
```

---

## ?? 使用场景

### 场景1: 修改放样点数后重新放样

```
操作流程:
1. 导入 STEP 文件（3条曲线）
2. 设置放样点数：10
3. 点击"放样全部"
   → 每条曲线生成 10 个点 ?
   
4. 修改放样点数：20
5. 再次点击"放样全部"
   → ? 弹出确认对话框
   → "检测到 3 条曲线已经放样过..."
   
6. 用户选择"是"
   → 重新放样所有曲线
   → 每条曲线生成 20 个点 ?
```

### 场景2: 部分曲线需要重新放样

```
操作流程:
1. 有 5 条曲线
2. 其中 3 条已放样（10 个点）
3. 修改放样点数：15
4. 点击"放样全部"
   → ? 弹出确认对话框
   → "检测到 3 条曲线已经放样过..."
   
选择"是":
  → 重新放样 5 条曲线（全部）
  → 所有曲线都是 15 个点 ?
  
选择"否":
  → 只放样未放样的 2 条曲线
  → 已放样的 3 条保持 10 个点
  → 新放样的 2 条是 15 个点
```

### 场景3: 单独重新放样某条曲线

```
操作流程:
1. 有 5 条已放样的曲线
2. 选中 usv_01
3. 修改其 LoftPointCount 为 25
4. 点击"放样选中"（或工具栏按钮）
   → ? 弹出确认对话框
   → "曲线 usv_01 已经放样过..."
   → "当前放样点数: 25"
   
5. 用户选择"是"
   → 重新放样 usv_01
   → usv_01 现在有 25 个点
   → 其他曲线不受影响 ?
```

---

## ?? 智能检测逻辑

### 检测已放样曲线

```csharp
// 获取所有已放样的曲线
var alreadyLoftedCurves = Curves.Where(c => c.IsLofted).ToList();

if (alreadyLoftedCurves.Count > 0)
{
    // 有已放样的曲线，需要询问用户
}
```

### 构建提示信息

```csharp
// 基本信息
var message = $"检测到 {alreadyLoftedCurves.Count} 条曲线已经放样过：\n\n";

// 列出曲线名称（最多5条）
message += string.Join("\n", 
    alreadyLoftedCurves
    .Take(5)
    .Select(c => $"  ? {c.Name}"));

// 如果超过5条，显示剩余数量
if (alreadyLoftedCurves.Count > 5)
{
    message += $"\n  ... 还有 {alreadyLoftedCurves.Count - 5} 条";
}

// 添加说明
message += "\n\n是否重新放样这些曲线？\n\n";
message += "选择：\n";
message += "? 是 - 重新放样所有曲线（包括已放样的）\n";
message += "? 否 - 只放样未放样的曲线";
```

### 根据用户选择执行

```csharp
var result = _dialogService.ShowConfirmation(message);
bool reloftAll = result;

foreach (var curve in Curves)
{
    // ? 智能判断：
    // - 如果未放样，总是放样
    // - 如果已放样，根据用户选择
    if (!curve.IsLofted || reloftAll)
    {
        // 执行放样...
    }
}
```

---

## ?? 完整流程图

### 单条曲线放样流程

```
用户点击"放样选中"
      ↓
检查 SelectedCurve
    ↓
   已放样？
   ├─ 是 → 弹出确认对话框
   │       ↓
   │  用户选择？
   │    ├─ 是 → 重新放样 ?
   │    └─ 否 → 取消操作
   │
   └─ 否 → 直接放样 ?
```

### 批量放样流程

```
用户点击"放样全部"
      ↓
检测已放样曲线数量
      ↓
  有已放样的？
   ├─ 是 → 弹出确认对话框
   │    ↓
   │    用户选择？
   │    ├─ 是 → 重新放样所有 ?
   │ └─ 否 → 只放样未放样的 ?
   │
   └─ 否 → 放样所有曲线 ?
```

---

## ? 优势总结

### 1. 安全性

```
? 总是询问用户意见
? 不会意外覆盖数据
? 提供清晰的选项说明
```

### 2. 灵活性

```
? 支持重新放样
? 支持选择性放样
? 支持单条和批量
```

### 3. 用户友好

```
? 清晰的提示信息
? 列出受影响的曲线
? 提供两种选择
? 显示当前放样点数
```

### 4. 智能性

```
? 自动检测已放样曲线
? 只在需要时提示
? 显示适量的信息（最多5条）
? 状态栏实时反馈
```

---

## ?? 状态栏消息

### 不同操作的提示

```
场景1: 重新放样
→ "已重新放样 3 条曲线"

场景2: 只放样未放样的
→ "已放样 2 条曲线"

场景3: 取消重新放样
→ "已取消重新放样"

场景4: 单条曲线放样
→ "曲线 usv_01 已放样，生成 20 个点"
```

---

## ?? 注意事项

### 1. 放样点数的来源

```
重要: 
- 每条曲线有自己的 LoftPointCount
- 修改"放样点数设置"只影响未放样的曲线
- 已放样的曲线保持原有点数

要修改已放样曲线的点数:
1. 方法1: 修改点数设置后重新放样
2. 方法2: 直接修改曲线的 LoftPointCount 属性
```

### 2. 生成步骤的影响

```
警告:
- 重新放样后，点数可能改变
- 如果已生成步骤，步骤数可能不一致
- 建议重新放样后重新生成步骤

流程:
1. 重新放样曲线
2. 删除旧步骤（清除所有步骤）
3. 重新生成步骤
```

### 3. 原始数据保护

```
安全:
? 原始点数据（OriginalPoints）不会改变
? 只更新放样点数据（LoftedPoints）
? 可以随时重新放样
```

---

## ?? 总结

### 修改前的问题

```
? 已放样的曲线无法重新放样
? 修改点数后无效
? 用户体验不好
```

### 修改后的改进

```
? 支持重新放样已放样曲线
? 智能检测并提示用户
? 提供灵活的选择
? 安全可靠
? 用户友好
```

---

## ?? 相关文档

- `放样功能使用指南.md` - 放样功能详细说明
- `放样点数设置修复快速参考.md` - 点数设置说明
- `3D视图实时更新功能增强.md` - 3D显示更新

---

**现在可以对已放样的曲线再次进行放样了！系统会智能提示并让您选择！** ??

---

**最后更新**: 2024-12-22  
**版本**: v2.0.8  
**状态**: ? 已实现并验证
